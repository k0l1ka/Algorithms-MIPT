\documentclass[a4paper,12pt]{article} % тип документа

% report, book

%  Русский язык

\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы


% Математика
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 


\usepackage{wasysym}
% мои добьавки-----------------------------------------
\usepackage{ dsfont }
\usepackage{listings}

%мое----------------------------------------------------
%Заговолок
\author{Попов Николай}
\title{Домашнее задание 5\\ по алгебре \LaTeX{}}

\begin{document} % начало документа


\newpage 

\section*{Задача 1}
Аналогии с топологической сортировкой получаем, что если цикл был бы, то было бы ребро ведущее из вершины с меньшим номером к вершине с меньшим номером, что противоречит условию.\\

\section*{Задача 2}
Будем "достраивать" путь, рассматривая подграфы исходного графа. На 2-х вершинах простой путь - это ребро. При добавлении 3 вершины перезаписываем путь. Если у нас есть простой путь длины n, то либо новая вершина добавится в начало этого пути, либо в конец, либо найдется пара вершин из пути, первая из которых входит в новую вершину а следующая выходит. т.е. в любом случае получим более длинный простой путь.\\
 Корректность: путь всегда простой и достраивание верно.\\
 Асимптотика:в поисках места для каждой новой вершины будем проходить по имеющемуся пути в поисках места для нее, выполняя сравнения. Получаем \[\sum_{i=2}^{n}ci=\Theta(n^2)\]

 
\section*{Задача 3}
a)Прямое ребро из вершины n в k: d(n)<d(k)<f(k)<f(n)
b)Перекрестное:d(n)<f(n)<d(k)<f(k) либо d(k)<f(k)<d(n)<f(n)

\section*{Задача 4}
в оргграфе найдем его компоненты сильной связности. Сделаем обход графа в глу-
бину, транспонируем граф и будем делать обход в глубину от вершин в порядке убывания времени закрытия. Полученные деревья и будут «областями». Корректность : так находятся компоненты силной связности.
Асимптотика составлена из проходов по всем вершинам (V)и транспонировании ребер(E). В итоге О(V+E).\\

\section*{Задача 5}
Цель в том, чтобы идти постоянно в новые комнаты если они есть. Будем действовать по аналогии с DFS. Для этого отметим первую комнату кучей монеток в центре. Затем будем помечать входы в туннели следующим образом: туннель откуда мы пришли пометим одной монетой, тогда всегда сможем вернуться. Пока можем идем идем в новые комнаты, если пришли туда где уже были или уходим из комнаты без выхода и неисследовательных туннелей, то двумя монетами "запираем этот туннель". В итоге, мы всегда знаем куда еще нужно и надо пойти и либо найдем выход, либо поймем что его нет, когда все туннели исследованы.\\
Корректность слдеует из идеи DFS, т.к. мы идем вглубь пока можем, иначе возвращаемся по пути спуска и снова идем пока можем из каждой комнаты на пути назад.\\
При этом через каждое ребро мы проходим два раза максимум, когда первый раз по нему проходим и если приходиться возвращаться по нему.Поэтому асимптотика линейна относительно числа коридоров.\\


\section*{Задача6}
Все ребра сонаправленные с ребрами в пути можно выкинуть (как в топологически отсортированном графе они не образуют циклов и К.С.Св.). Далее работаем с ребрами направленными противоположно. 
Отсортируем все эти ребра по возрастанию концов.
Если два ребра "пересекаются" по вершинам, то они входят в одну компоненту связности, т.е. нужно  посчитать число разрывов по вершинам между группами пересекающихся ребер в отсортированном массиве ребер. \\
Сортировка работает за O(mlog(m)), потом пройдемся по m ребрам и увеличиваем счетчик если if end(i+1)<=start(i) (count++).Ответ count+1.\\




\section*{Задача 7(семинар)}
Конденсат этого графа он сам. значит, граф DAG, т.к. конденсат - DAG.
\end{document}